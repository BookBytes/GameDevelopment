<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>
<link rel="stylesheet" href="../stylesheets/default.css" type="text/css" media="screen" />
<title>COMP 23: Introduction to Game Development - Physics</title>
</head>

<body>
<div id="main">

<div id = "header">
<h1>Introduction to Game Development</h1>
<h2>Physics</h2>
</div>

<h3>Basic Physics: Preliminaries</h3>
<ul>
<li>We will assume fixed discrete simulation (constant time step)</li>
<li>Approximation</li>
<li>Remember, we are working with a 2D coordinate system</li>
<li>If you need a formula (e.g., that involves forces or mass), <span class="stress">look it up!</span></li>
<li>Keep it simple!</li>
<li>We will use the metric system (e.g., m, m/s)</li>
</ul>

<h3>Position and Velocity</h3>
<ul>
<li>Question: Where is the object at time <span class="stress">t</span>?</li>
<li><span class="stress">Velocity</span> - "The rate of change of position along a straight line with respect to time"</li>
<li>Remember, speed and velocity are not the same: velocity is a vector quantity (has direction) while speed is a scalar quantity</li>
<li>Given variables: <code>object_x</code>, <code>object_y</code>, <code>speed</code>, <code>angle</code></li>
<li>Calculation (in your game loop):
<ul>
<li><code>scale_x = cos(angle)</code></li>
<li><code>scale_y = sin(angle)</code></li>
<li><code>velocity_x = (speed * scale_x)</code></li>
<li><code>velocity_y = (speed * scale_y)</code></li>
<li><code>object_x = object_x + velocity_x</code></li>
<li><code>object_y = object_y + velocity_y</code></li>
</ul>
</li>
</ul>

<h3>Acceleration</h3>
<ul>
<li><span class="stress">Acceleration</span> - "The rate of change of velocity with respect to time"</li>
<li>When an object moves along at a certain velocity, an amount of acceleration is continuously added to the velocity</li>
<li>Given variables: <code>object_x</code>, <code>object_y</code>, <code>speed</code>, <code>acceleration</code>, <code>angle</code></li>
<li>Calculation (in your game loop):
<ul>
<li><code>scale_x = cos(angle)</code></li>
<li><code>scale_y = sin(angle)</code></li>
<li><span class="stress"><code>speed = speed + acceleration</code></span></li>
<li><code>velocity_x = (speed * scale_x)</code></li>
<li><code>velocity_y = (speed * scale_y)</code></li>
<li><code>object_x = object_x + velocity_x</code></li>
<li><code>object_y = object_y + velocity_y</code></li>
</ul>
</li>
</ul>

<h3>Gravity</h3>
<ul>
<li>Downwards acceleration</li>
<li>Earth's gravity constant = 9.81 meters per second squared</li>
<li>In a game, the gravity constant depends on frame rate and the effect</li>
<li>Given variables: <code>object_x</code>, <code>object_y</code></li>
<li>Calculation (in your game loop; assume that the object is moving):
<ul>
<li><code>velocity_y = velocity_y - gravity</code></li>
<li>(If the object has not hit the ground yet) <code>object_y = object_y + velocity_y</code></li>
<li><code>object_x = object_x + velocity_x</code></li>
</ul>
</li>
<li><span class="stress">Where useful:</span> a character jumping in a sidescroller, projectiles</li>
</ul>

<h3>Projectiles</h3>
<ul>
<li>See <a href="http://oreilly.com/catalog/physicsgame/chapter/ch06.pdf" target="_blank">http://oreilly.com/catalog/physicsgame/chapter/ch06.pdf</a></li>
</ul>

<h3>Collision:</h3>
<ul>
<li>Detection:
<ul>
<li>Bounding box method</li>
<li>Problem: irregularly shaped objects (thus wasted space).  However, empirically, less space will be wasted using the bounding box method over bounding sphere method.</li>
<li>Collision test, two methods:
<ol>
<li><code>if (object.x &gt;= box.min_x and object.x &lt;= box.max_x and object.y &gt;= box.min_y and object.y &lt;= box.max_y)</code> then collision occurred
<ul>
<li>Use this same approach for <span class="stress">mouse picking</span>!  That is when in handling mouse events, check to see if the object was picked via x-y coordinates.</li>
</ul>
</li>
<li>Use Pygame's sprite collision methods: <code>pygame.sprite.collide_rect()</code>, <code>pygame.sprite.collide_circle()</code>
<ul>
<li>Each method returns either <code>True</code> or <code>False</code></li>
<li>Ideally used for detecting collision of objects (e.g., cars)</li>
<li>Each method takes in two sprites (must extend one of Pygame's sprite base classes)</li>
<li>Sprite must have <code>rect</code> attribute and set the location of the bounding box.  That is:
<pre>
    self.x = x
    self.y = y
    self.rect = self.image.get_rect()
    self.image_w, self.image_h = self.image.get_size()
    self.rect.move(self.x, self.y)
    self.rect.topleft = (self.x, self.y)
    self.rect.bottomright = (self.x + self.image_w, self.y + self.image_h)  
</pre>
</li>
<li class="note">Each time you move a sprite, you also have to change the location (including the topleft and bottomright) of the bounding box!</li>
<li>More details: <a href="http://www.pygame.org/docs/ref/sprite.html" target="_blank">http://www.pygame.org/docs/ref/sprite.html</a></li>
<li>Example:
<pre>
  sprite1 = SimpleSprite(...)
  sprite2 = SimpleSprite(...)
  if pygame.sprite.collide_rect(sprite1, sprite2):
    # Do something
</pre>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Different objects respond differently to collisions</li>
<li>For most collisions however, most collisions will resemble exactly that of balls in the game of pool (elastic collision)</li>
<li><span class="stress">Angle of incidence</span> - The angle between the ball movement vector and the plane of the rail that it strikes when the ball moving in a straight line collides with it.  Remember, when the ball hits the rail, it will bounce away from the rail at the same angle that it strikes the rail.  In other words, the angle of reflection = angle of incidence</li>
<li>Calculation:
<pre>
  if (ballPoint.x + ballSpeed.x) &lt;= plane.x:
      ballSpeed.x = (ballSpeed.x * -1)
  if (ballPoint.x + ballSpeed.x) &gt;= plane.width:
    ballSpeed.x = (ballSpeed.x * -1)
  if (ballPoint.y + ballSpeed.y) &lt;= plane.y:
    ballSpeed.y = (ballSpeed.y * -1)
  if (ballPoint.y + ballSpeed.y) &gt;= plane.height:
    ballSpeed.y = (ballSpeed.y * -1)
</pre>
</li>
<li>Why does the above work?  Think back to high school algebra and geometry...</li>
</ul>
</li>
</ul>

</div>

<script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
  try {
    var pageTracker = _gat._getTracker("UA-582953-7");
    pageTracker._trackPageview();
  }
  catch(err) {}
</script>

</body>
</html>
